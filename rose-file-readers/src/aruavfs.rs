use std::{collections::HashMap, fs::File, io::Read, num::Wrapping, path::Path};

use ctr::cipher::{KeyIvInit, StreamCipher};
use flate2::read::ZlibDecoder;
use memmap::{Mmap, MmapOptions};
use thiserror::Error;

use crate::{reader::RoseFileReader, VfsError, VfsFile, VfsPath, VirtualFilesystemDevice};

#[derive(Error, Debug)]
pub enum AruaVfsError {
    #[error("Decryption failed")]
    DecryptionFailed,
}

/// VFS format used by AruaROSE, format is identical to TitanVFS but with added file encryption.
#[derive(Debug)]
pub struct AruaVfsIndex {
    pub version: u32,
    files: HashMap<u32, (u64, u32)>,
    mmap: Mmap,
}

fn crypt_data(data: &mut [u8], hash: u32) {
    let next_hash_index = [3, 2, 0, 1];
    let byte_hash = hash.to_le_bytes();
    let mut current_byte_hash_index = 0;

    for b in data.iter_mut().take(32) {
        *b ^= byte_hash[current_byte_hash_index];
        current_byte_hash_index = next_hash_index[current_byte_hash_index];
    }
}

fn generate_hash(data: &[u8], next_hash: u32) -> u32 {
    let mut byte_hash = next_hash.to_le_bytes();
    for i in 0..32 {
        let mut val = byte_hash[((data[i] as u32 % 1337) % 4) as usize];
        if val == 0 {
            for b in &byte_hash {
                val |= b;
            }

            for b in &byte_hash {
                val ^= b;
            }
        }

        byte_hash[((data[i] % 23) % 4) as usize] ^=
            (((val as i32 - 3) % 63) | ((val as i32 + 5) % 37) ^ ((val as i32 % 25) + 6)) as u8;
    }

    u32::from_le_bytes(byte_hash)
}

#[derive(Copy, Clone, Hash, Eq, PartialEq, Debug)]
pub struct FileNameHash {
    pub hash: u32,
}

impl FileNameHash {
    pub fn new(hash: u32) -> Self {
        Self { hash }
    }
}

const HASH_TABLE: [u32; 256] = [
    0x697A5, 0x6045C, 0xAB4E2, 0x409E4, 0x71209, 0x32392, 0xA7292, 0xB09FC, 0x4B658, 0xAAAD5,
    0x9B9CF, 0xA326A, 0x8DD12, 0x38150, 0x8E14D, 0x2EB7F, 0xE0A56, 0x7E6FA, 0xDFC27, 0xB1301,
    0x8B4F7, 0xA7F70, 0xAA713, 0x6CC0F, 0x6FEDF, 0x2EC87, 0xC0F1C, 0x45CA4, 0x30DF8, 0x60E99,
    0xBC13E, 0x4E0B5, 0x6318B, 0x82679, 0x26EF2, 0x79C95, 0x86DDC, 0x99BC0, 0xB7167, 0x72532,
    0x68765, 0xC7446, 0xDA70D, 0x9D132, 0xE5038, 0x2F755, 0x9171F, 0xCB49E, 0x6F925, 0x601D3,
    0x5BD8A, 0x2A4F4, 0x9B022, 0x706C3, 0x28C10, 0x2B24B, 0x7CD55, 0xCA355, 0xD95F4, 0x727BC,
    0xB1138, 0x9AD21, 0xC0ACA, 0xCD928, 0x953E5, 0x97A20, 0x345F3, 0xBDC03, 0x7E157, 0x96C99,
    0x968EF, 0x92AA9, 0xC2276, 0xA695D, 0x6743B, 0x2723B, 0x58980, 0x66E08, 0x51D1B, 0xB97D2,
    0x6CAEE, 0xCC80F, 0x3BA6C, 0xB0BF5, 0x9E27B, 0xD122C, 0x48611, 0x8C326, 0xD2AF8, 0xBB3B7,
    0xDED7F, 0x4B236, 0xD298F, 0xBE912, 0xDC926, 0xC873F, 0xD0716, 0x9E1D3, 0x48D94, 0x9BD91,
    0x5825D, 0x55637, 0xB2057, 0xBCC6C, 0x460DE, 0xAE7FB, 0x81B03, 0x34D8F, 0xC0528, 0xC9B59,
    0x3D260, 0x6051D, 0x93757, 0x8027F, 0xB7C34, 0x4A14E, 0xB12B8, 0xE4945, 0x28203, 0xA1C0F,
    0xAA382, 0x46ABB, 0x330B9, 0x5A114, 0xA754B, 0xC68D0, 0x9040E, 0x6C955, 0xBB1EF, 0x51E6B,
    0x9FF21, 0x51BCA, 0x4C879, 0xDFF70, 0x5B5EE, 0x29936, 0xB9247, 0x42611, 0x2E353, 0x26F3A,
    0x683A3, 0xA1082, 0x67333, 0x74EB7, 0x754BA, 0x369D5, 0x8E0BC, 0xABAFD, 0x6630B, 0xA3A7E,
    0xCDBB1, 0x8C2DE, 0x92D32, 0x2F8ED, 0x7EC54, 0x572F5, 0x77461, 0xCB3F5, 0x82C64, 0x35FE0,
    0x9203B, 0xADA2D, 0xBAEBD, 0xCB6AF, 0xC8C9A, 0x5D897, 0xCB727, 0xA13B3, 0xB4D6D, 0xC4929,
    0xB8732, 0xCCE5A, 0xD3E69, 0xD4B60, 0x89941, 0x79D85, 0x39E0F, 0x6945B, 0xC37F8, 0x77733,
    0x45D7D, 0x25565, 0xA3A4E, 0xB9F9E, 0x316E4, 0x36734, 0x6F5C3, 0xA8BA6, 0xC0871, 0x42D05,
    0x40A74, 0x2E7ED, 0x67C1F, 0x28BE0, 0xE162B, 0xA1C0F, 0x2F7E5, 0xD505A, 0x9FCC8, 0x78381,
    0x29394, 0x53D6B, 0x7091D, 0xA2FB1, 0xBB942, 0x29906, 0xC412D, 0x3FCD5, 0x9F2EB, 0x8F0CC,
    0xE25C3, 0x7E519, 0x4E7D9, 0x5F043, 0xBBA1B, 0x6710A, 0x819FB, 0x9A223, 0x38E47, 0xE28AD,
    0xB690B, 0x42328, 0x7CF7E, 0xAE108, 0xE54BA, 0xBA5A1, 0xA09A6, 0x9CAB7, 0xDB2B3, 0xA98CC,
    0x5CEBA, 0x9245D, 0x5D083, 0x8EA21, 0xAE349, 0x54940, 0x8E557, 0x83EFD, 0xDC504, 0xA6059,
    0xB85C9, 0x9D162, 0x7AEB6, 0xBED34, 0xB4963, 0xE367B, 0x4C891, 0x9E42C, 0xD4304, 0x96EAA,
    0xD5D69, 0x866B8, 0x83508, 0x7BAEC, 0xD03FD, 0xDA122,
];
const HASH_SEED1: u32 = 0xDEADC0DEu32;
const HASH_SEED2: u32 = 0x7FED7FEDu32;

impl From<&str> for FileNameHash {
    fn from(path: &str) -> Self {
        let path = path.replace('/', "\\").replace("\\\\", "\\");

        if path.is_empty() {
            Self::new(0)
        } else {
            let mut seed1 = Wrapping(HASH_SEED1);
            let mut seed2 = Wrapping(HASH_SEED2);

            for ch in path
                .chars()
                .map(|c| Wrapping(c.to_ascii_uppercase() as u32))
            {
                seed1 = Wrapping(HASH_TABLE[(ch.0 & 0xff) as usize]) ^ (seed1 + seed2);
                seed2 = ch + seed1 + seed2 + (seed2 << 5) + Wrapping(3);
            }

            Self::new(seed1.0)
        }
    }
}

impl AruaVfsIndex {
    pub fn load(index_path: &Path, data_path: &Path) -> Result<Self, anyhow::Error> {
        let mut data = std::fs::read(index_path)?;
        let mut reader = RoseFileReader::from(&data);

        let version = reader.read_u32()?;
        let mut file_count = reader.read_u32()?;
        let is_encrypted = (file_count & (1 << 28)) != 0;

        if is_encrypted {
            let mut hash = file_count;
            file_count ^= 0x1337BEEF;

            let mut next_hash: u32;
            let mut pos = 8;
            while pos + 32 < data.len() {
                next_hash = generate_hash(&data[pos..], hash);
                crypt_data(&mut data[pos..], hash);
                pos += 32;
                hash = next_hash;
            }
        }

        let mut reader = RoseFileReader::from(&data[8..]);
        let mut files = HashMap::with_capacity(file_count as usize);
        for _ in 0..file_count {
            let text_hash = reader.read_u32()?;
            let size = reader.read_u32()?;
            let offset = reader.read_u64()?;
            files.insert(text_hash, (offset, size));
        }

        let file = File::open(data_path)?;
        let mmap = unsafe { MmapOptions::new().map(&file)? };

        Ok(Self {
            version,
            files,
            mmap,
        })
    }
}

const _GLOBAL_KEY: [u8; 16] = [
    0x26, 0x23, 0xE4, 0x42, 0x91, 0xDD, 0x58, 0x39, 0x0C, 0xBF, 0xF6, 0x90, 0xDA, 0x05, 0x3A, 0x03,
];
const _GLOBAL_IV: [u8; 16] = [
    0x53, 0x80, 0xFE, 0x53, 0x32, 0x63, 0xB6, 0xF6, 0x19, 0xA9, 0xE0, 0xD6, 0xEF, 0x78, 0xB8, 0x98,
];

const CHR_KEY: [u8; 16] = [
    0xCD, 0x5E, 0xDC, 0xE6, 0x12, 0xA6, 0x5C, 0x7B, 0x36, 0x84, 0xC6, 0xE1, 0x8D, 0x69, 0xC7, 0xCB,
];
const CHR_IV: [u8; 16] = [
    0xC2, 0xBC, 0xF8, 0xC5, 0x73, 0x07, 0x4F, 0x19, 0xF9, 0x79, 0xF2, 0xA2, 0x99, 0xC1, 0x92, 0x05,
];

const CON_KEY: [u8; 16] = [
    0x41, 0x68, 0xF1, 0x61, 0x02, 0xA3, 0x57, 0xF8, 0x5B, 0x57, 0x8D, 0x42, 0xF5, 0x29, 0xE8, 0x5B,
];
const CON_IV: [u8; 16] = [
    0xC2, 0x04, 0xAF, 0x28, 0x3E, 0x76, 0x43, 0xE5, 0x7D, 0x1C, 0x04, 0x01, 0x65, 0x15, 0x06, 0x3A,
];

const HIM_KEY: [u8; 16] = [
    0x43, 0x16, 0xE3, 0xB3, 0x53, 0x12, 0x72, 0x9F, 0xBD, 0xB3, 0xAA, 0x7A, 0x67, 0x9C, 0x6C, 0xF6,
];
const HIM_IV: [u8; 16] = [
    0x87, 0xBE, 0x18, 0xBC, 0x4C, 0x74, 0xEB, 0x39, 0xC3, 0x6B, 0x54, 0xA2, 0x38, 0x48, 0xFE, 0xFE,
];

const IFO_KEY: [u8; 16] = [
    0xE9, 0xA0, 0x44, 0xC0, 0x0D, 0xBB, 0x35, 0x05, 0xA6, 0xA3, 0xE3, 0x6E, 0x6C, 0xE6, 0x1B, 0xAC,
];
const IFO_IV: [u8; 16] = [
    0x51, 0x86, 0x8A, 0xA8, 0xF7, 0x28, 0xA5, 0x3F, 0xB8, 0x1A, 0xFC, 0xC8, 0x74, 0xB0, 0xA4, 0x94,
];

const LIT_KEY: [u8; 16] = [
    0x56, 0x30, 0xEA, 0x1E, 0x42, 0xE3, 0x0C, 0xDB, 0x52, 0xBD, 0x6A, 0x3C, 0x74, 0x1E, 0xB7, 0x12,
];
const LIT_IV: [u8; 16] = [
    0xDA, 0x25, 0x83, 0xFA, 0xD9, 0x14, 0xBD, 0x9F, 0xB4, 0x86, 0xDA, 0xD6, 0x94, 0x53, 0xA6, 0x3F,
];

const LTB_KEY: [u8; 16] = [
    0xDA, 0xA5, 0xB6, 0xD6, 0xDE, 0xC5, 0x32, 0xE1, 0xA8, 0x43, 0x62, 0xB2, 0xA1, 0x90, 0xB2, 0x8D,
];
const LTB_IV: [u8; 16] = [
    0xCB, 0xB3, 0xEF, 0x9E, 0x27, 0xDD, 0x19, 0xEE, 0x01, 0xC7, 0x1E, 0x32, 0x41, 0x60, 0x0B, 0x59,
];

const QSD_KEY: [u8; 16] = [
    0xF9, 0x2B, 0x2C, 0xA6, 0xCA, 0x84, 0x11, 0x3D, 0x49, 0x78, 0xBF, 0x28, 0x5C, 0xE9, 0xFE, 0x02,
];
const QSD_IV: [u8; 16] = [
    0x6E, 0x0B, 0xE7, 0x7D, 0x69, 0x08, 0x3B, 0xAF, 0x57, 0x89, 0x38, 0x8F, 0xC3, 0xAA, 0x98, 0xD7,
];

const STB_KEY: [u8; 16] = [
    0x6B, 0xB7, 0x28, 0x69, 0x76, 0xAB, 0x0A, 0x79, 0xE5, 0x20, 0x0B, 0x02, 0xAF, 0x06, 0x52, 0xC5,
];
const STB_IV: [u8; 16] = [
    0x7D, 0x12, 0x59, 0xEB, 0x51, 0x03, 0xCD, 0xE5, 0xE5, 0xDC, 0x49, 0x69, 0xF8, 0x17, 0x51, 0x5E,
];

const _STL_KEY: [u8; 16] = [
    0x6B, 0xB7, 0x28, 0x69, 0x76, 0xAB, 0x0A, 0x79, 0xE5, 0x20, 0x0B, 0x02, 0xAF, 0x06, 0x52, 0xC5,
];
const _STL_IV: [u8; 16] = [
    0x7D, 0x12, 0x59, 0xEB, 0x51, 0x03, 0xCD, 0xE5, 0xE5, 0xDC, 0x49, 0x69, 0xF8, 0x17, 0x51, 0x5E,
];

const XML_KEY: [u8; 16] = [
    0xA1, 0x5F, 0x45, 0x90, 0x6F, 0x7B, 0x2C, 0xF9, 0x29, 0x5D, 0x59, 0x63, 0xFF, 0xA5, 0xB2, 0x8A,
];
const XML_IV: [u8; 16] = [
    0xD0, 0xAF, 0x7B, 0xEC, 0xDD, 0x5B, 0x3A, 0xCE, 0xC4, 0xEB, 0x2F, 0x6B, 0xCB, 0xBF, 0xAB, 0xE0,
];

const ZON_KEY: [u8; 16] = [
    0x3E, 0xFB, 0x07, 0x01, 0xC3, 0xC6, 0x64, 0xC1, 0x37, 0x71, 0x9F, 0x3D, 0x89, 0x91, 0xEA, 0x94,
];
const ZON_IV: [u8; 16] = [
    0x12, 0x40, 0x08, 0xC7, 0x32, 0x7A, 0xC9, 0xAA, 0x41, 0x54, 0xDE, 0x01, 0x23, 0xBE, 0x50, 0x50,
];

const ZSC_KEY: [u8; 16] = [
    0xB3, 0xA6, 0x29, 0x17, 0xC5, 0xED, 0x8A, 0xA8, 0x8F, 0x9A, 0x67, 0xF5, 0x01, 0x89, 0xA3, 0x26,
];
const ZSC_IV: [u8; 16] = [
    0x36, 0x4A, 0xAC, 0x9B, 0xD6, 0xDC, 0x84, 0x8F, 0xD5, 0xFF, 0xF5, 0x4A, 0xCB, 0x5D, 0xC8, 0x63,
];

impl VirtualFilesystemDevice for AruaVfsIndex {
    fn open_file(&self, vfs_path: &VfsPath) -> Result<VfsFile, anyhow::Error> {
        let path_str = vfs_path.path().to_str().unwrap();
        let &(offset, size) = self
            .files
            .get(&FileNameHash::from(path_str).hash)
            .ok_or_else(|| VfsError::FileNotFound(vfs_path.path().into()))?;
        let file_data = &self.mmap[offset as usize..offset as usize + size as usize];

        let crypto = match vfs_path.path().extension().and_then(|x| x.to_str()) {
            Some("CHR") => Some((CHR_KEY, CHR_IV, true)),
            Some("CON") => Some((CON_KEY, CON_IV, true)),
            Some("HIM") => Some((HIM_KEY, HIM_IV, true)),
            Some("IFO") => Some((IFO_KEY, IFO_IV, true)),
            Some("LIT") => Some((LIT_KEY, LIT_IV, false)),
            Some("LTB") => Some((LTB_KEY, LTB_IV, true)),
            Some("QSD") => Some((QSD_KEY, QSD_IV, false)),
            Some("STB") => Some((STB_KEY, STB_IV, true)),
            Some("STL") => None, // Some((STL_KEY, STL_IV)),
            Some("XML") => Some((XML_KEY, XML_IV, true)),
            Some("ZON") => Some((ZON_KEY, ZON_IV, true)),
            Some("ZSC") => Some((ZSC_KEY, ZSC_IV, true)),
            _ => None,
        };

        if let Some((crypto_key, crypto_iv, compressed)) = crypto {
            let mut cipher =
                ctr::Ctr128BE::<aes::Aes128>::new(&crypto_key.into(), &crypto_iv.into());
            let mut decrypted = vec![0u8; file_data.len()];
            if cipher
                .apply_keystream_b2b(file_data, &mut decrypted)
                .is_err()
            {
                return Err(AruaVfsError::DecryptionFailed.into());
            }

            if !compressed {
                Ok(VfsFile::Buffer(decrypted))
            } else {
                let mut decoder = ZlibDecoder::new(&decrypted[..]);
                let mut decompressed = Vec::new();
                decoder.read_to_end(&mut decompressed)?;
                Ok(VfsFile::Buffer(decompressed))
            }
        } else {
            Ok(VfsFile::View(file_data))
        }
    }

    fn exists(&self, vfs_path: &VfsPath) -> bool {
        let path_str = vfs_path.path().to_str().unwrap();
        self.files.get(&FileNameHash::from(path_str).hash).is_some()
    }
}
